// -*- mode: java -*-
component client(byte numOfPorts){
    byte data := 0;
    byte numOfOpenedServers := 0;

    required port service[numOfPorts]{
        @interaction{
            waits: numOfOpenedServers < numOfPorts;
        }
        @functional{
            requires: true;
            ensures: numOfOpenedServers:=numOfOpenedServers +1;
        }
        void open();

        @interaction{
            waits: numOfOpenedServers > 0;
        }
        @functional{
            requires: true;
            ensures: numOfOpenedServers:=numOfOpenedServers - 1;
        }
        void close();

        @interaction{
            waits: numOfOpenedServers == numOfPorts;
        }
        @functional{
            requires: true;
            ensures: data:= \result;
        }
        byte request();
    }
}

component server(byte numOfPorts){
    bool opened[numOfPorts] := false;
    byte data := 1;

    provided port service[numOfPorts] {
        void open();
        void close();

        @functional{
            requires:true;
            ensures: \result := data  ;
        }
        byte request();
    }
}

component mixedComponent(byte numOfClientPorts, byte numOfServerPorts){
    byte numOfOpenedServers := 0;
    byte data := 3;

    //      [blocking]
    required port client[numOfClientPorts]{
        @interaction{
            waits: numOfOpenedServers < numOfClientPorts;
        }
        @functional{
            requires:true;
            ensures:  numOfOpenedServers:=numOfOpenedServers +1;
        }
        void open();

        @interaction{
            waits: numOfOpenedServers > 0;
        }
        @functional{
            requires:true;
            ensures:  numOfOpenedServers:=numOfOpenedServers - 1;
        }
        void close();

        @interaction{
            waits: numOfOpenedServers == numOfClientPorts;
        }
        @functional{
            requires:true;
            ensures: data := \result;
        }
        byte request();
    }

    provided port server[numOfServerPorts]{
        @interaction{
            waits: numOfOpenedServers == numOfClientPorts;
        }
        void open();

        @interaction{
            waits: numOfOpenedServers == numOfClientPorts;
        }
        void close();

        @interaction{
            waits: numOfOpenedServers == numOfClientPorts;
        }
        @functional{
            requires: true;
            ensures: \result := data;
        }
        byte request();
    }
}

connector client2server(client{service}, server{service}){
    role client{
        bool opened := false;
        required port_variable service{
            @interaction{
                allows: !opened;
                ensures: opened := true;
            }
            void open();
            @interaction{
                allows: opened;
                ensures: opened := false;
            }
            void close();
            @interaction{
                allows: opened  ;
                ensures: skip;
            }
            byte request();
        }
    }

    role server{
        bool opened:=false;
        provided port_variable service{
            @interaction{
                allows: !opened;
                ensures: opened:=true;
            }
            void open();
            @interaction{
                allows: opened;
                ensures: opened:= false;
            }
            void close();
            @interaction{
                allows: opened;
                ensures: skip;
            }
            byte request();
        }
    }

    connector proc link(client{service}, server{service});
}

connector client2server_deadlock(byte numOfClients, byte numOfServers, client{service}, server{service}){
    role client{
        bool opened := false;
        byte clientIndex := 0;

        required port_variable service{
            @interaction{
                allows: !opened ;
                ensures: opened := true;
            }
            void open();
            @interaction{
                allows: opened;
                ensures: opened := false;
            }
            void close();
            @interaction{
                allows: opened && clientIndex == @;
                ensures: clientIndex \in [0, numOfClients-1];
            }
            byte request();
        }
    }

    role server{
        bool opened:=false;
        byte serverIndex := 0;

        provided port_variable service{
            @interaction{
                allows: !opened;
                ensures: opened:=true;
            }
            void open();
            @interaction{
                allows: opened ;
                ensures: opened:= false;
            }
            void close();
            @interaction{
                allows: opened  && serverIndex == @;
                ensures: serverIndex \in [0, numOfServers-1];
            }
            byte request();
        }
    }

    connector proc link(client{service}, server{service});
}

composite aegis(){
    component server experimentControl(3);
    component mixedComponent doctrineAuthoring(1,3);
    component client doctrineValidation(3);
    component mixedComponent trackServer(1,3);
    component mixedComponent geoServer(2,1);
    component client doctrineReasoning(3);

    connector client2server_deadlock cs_1(1, 3, doctrineAuthoring{client[0]}, experimentControl{service[0]});
    connector client2server_deadlock cs_2(3, 3, doctrineValidation{service[0]},experimentControl{service[1]});
    connector client2server_deadlock cs_3(1, 3, trackServer{client[0]},experimentControl{service[2]});
    connector client2server_deadlock cs_4(3, 3, doctrineValidation{service[1]},doctrineAuthoring{server[0]});
    connector client2server_deadlock cs_5(3, 3, doctrineValidation{service[2]},trackServer{server[0]});
    connector client2server_deadlock cs_6(3, 3, doctrineReasoning{service[0]},doctrineAuthoring{server[1]});
    connector client2server_deadlock cs_7(2, 3, geoServer{client[0]},doctrineAuthoring{server[2]});
    connector client2server_deadlock cs_8(3, 3, doctrineReasoning{service[1]},trackServer{server[1]});
    connector client2server_deadlock cs_9(2, 3, geoServer{client[1]},trackServer{server[2]});
    connector client2server_deadlock cs_10(3, 1, doctrineReasoning{service[2]}, geoServer{server[0]});
}

component aegis configAegis();
