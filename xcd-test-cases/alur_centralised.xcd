// -*- mode: java -*-
enum order := { none, incFirst, dblFirst }; // order: a new type

connector centralised(roleP1{toUR,   toNA},
                      roleP2{toUR, toNA},
                      roleUR{inc,  double},
                      roleNA{inc,  double},
                      roleController{P1toUR,   P1toNA,
                              P2toUR,   P2toNA,
                              CtoURinc, CtoURdouble,
                              CtoNAinc, CtoNAdouble}){

    role roleP1{
        bool urFirst:=false;
        required port_variable toUR{
            @interaction{ allows: !urFirst;
                ensures: urFirst := true; }
            void incURF(); }
        required port_variable toNA{
            @interaction{ allows: urFirst;
                ensures: urFirst := false; }
            void incNAF(); }
    }
    role roleUR{
        provided port_variable inc{ void incURF(); }
        provided port_variable double{ void doubleURF(); }
    }
    role roleNA{
        provided port_variable inc{ void incNAF(); }
        provided port_variable double{ void doubleNAF(); }
    }
    role roleP2{
        bool urFirst:=false;
        required port_variable toNA{
            @interaction{ allows: urFirst;
                ensures: urFirst := false; }
            void doubleNAF(); }
        required port_variable toUR{
            @interaction{ allows: !urFirst;
                ensures: urFirst := true; }
            void doubleURF(); }
    }

    role roleController{
        order corder := none;
        bool p1_incNARcvd :=false;
        bool p1_incURRcvd :=false;
        bool p2_dblNARcvd :=false;
        bool p2_dblURRcvd :=false;
        bool ur_incUREmtd := false;
        bool na_incNAEmtd := false;
        bool ur_dblUREmtd := false;
        bool na_dblNAEmtd := false;

        all_received() { return p1_incURRcvd && p1_incNARcvd
                && p2_dblURRcvd && p2_dblNARcvd; }
        inc_emitted() { return ur_incUREmtd && na_incNAEmtd ; }
        dbl_emitted() { return ur_dblUREmtd && na_dblNAEmtd ; }

        provided port_variable P1toUR{
            @interaction{
                allows: !p1_incURRcvd;
                ensures: p1_incURRcvd :=true;
                corder := (corder == none)
                    ? incFirst : corder ; }
            void incURF(); }
        provided port_variable P1toNA{
            @interaction{
                allows:  !p1_incNARcvd;
                ensures: p1_incNARcvd :=true; }
            void incNAF(); }
        provided port_variable P2toUR{
            @interaction{
                allows:   !p2_dblURRcvd;
                ensures: p2_dblURRcvd :=true;
                corder := (corder == none)
                    ? dblFirst : corder ; }
            void doubleURF(); }
        provided port_variable P2toNA{
            @interaction{
                allows:   !p2_dblNARcvd;
                ensures: p2_dblNARcvd :=true; }
            void doubleNAF(); }

        required port_variable CtoURinc{
            @interaction{
                allows: all_received() && !ur_incUREmtd
                    && ( (corder==incFirst)
                         || (corder==dblFirst && dbl_emitted()) );
                ensures: ur_incUREmtd := true; }
            void incURF(); }

        required port_variable CtoURdouble{
            @interaction{
                allows: all_received() && !ur_dblUREmtd
                    && ( (corder==dblFirst)
                         || (corder==incFirst && inc_emitted()) );
                ensures: ur_dblUREmtd := true; }
            void doubleURF(); }

        required port_variable CtoNAinc{
            @interaction{
                allows: ur_incUREmtd && !na_incNAEmtd;
                ensures: // clear flags if dblFirst
                p1_incURRcvd := !(corder == dblFirst);
                p1_incNARcvd := !(corder == dblFirst);
                ur_incUREmtd := !(corder == dblFirst);
                na_incNAEmtd := !(corder == dblFirst);
                p2_dblURRcvd := !(corder == dblFirst);
                p2_dblNARcvd := !(corder == dblFirst);
                ur_dblUREmtd := (corder == dblFirst)
                    ? false : ur_dblUREmtd ;
                na_dblNAEmtd := (corder == dblFirst)
                    ? false : na_dblNAEmtd ;
                corder := (corder == dblFirst)
                    ? none : corder ; }
            void incNAF(); }

        required port_variable CtoNAdouble{
            @interaction{
                allows: ur_dblUREmtd && !na_dblNAEmtd;
                ensures: // clear flags if incFirst
                p2_dblURRcvd := !(corder == incFirst);
                p2_dblNARcvd := !(corder == incFirst);
                ur_dblUREmtd := !(corder == incFirst);
                na_dblNAEmtd := !(corder == incFirst);
                p1_incURRcvd := !(corder == incFirst);
                p1_incNARcvd := !(corder == incFirst);
                ur_incUREmtd := (corder == incFirst)
                    ? false : ur_incUREmtd ;
                na_incNAEmtd := (corder == incFirst)
                    ? false : na_incNAEmtd ;
                corder := (corder == incFirst)
                    ? none : corder ; }
            void doubleNAF(); }
    }
    // Controller appears to P1 & P2 as UR & NA
    connector async link1(roleP1{toUR},
                          roleController{P1toUR});
    connector async link2(roleP1{toNA},
                          roleController{P1toNA});
    connector async link3(roleP2{toUR},
                          roleController{P2toUR});
    connector async link4(roleP2{toNA},
                          roleController{P2toNA});
    // Controller appears to UR & NA as P1 & P2
    connector async link5(roleUR{inc},
                          roleController{CtoURinc});
    connector async link6(roleUR{double},
                          roleController{CtoURdouble});
    connector async link7(roleNA{inc},
                          roleController{CtoNAinc});
    connector async link8(roleNA{double},
                          roleController{CtoNAdouble});
}

component P1(){
    required port incUR{ void incURF(); }
    required port incNA{ void incNAF(); }
}
component P2(){
    required port doubleUR{ void doubleURF(); }
    required port doubleNA{ void doubleNAF(); }
}
component NA(){
    provided port incNA{ void incNAF(); }
    provided port doubleNA{ void doubleNAF(); }
}
component UR(){
    provided port incUR{ void incURF(); }
    provided port doubleUR{ void doubleURF(); }
}
component controller{
    provided port P1_incUR{ void incURF(); }
    provided port P1_incNA{ void incNAF(); }
    provided port P2_doubleUR{ void doubleURF(); }
    provided port P2_doubleNA{ void doubleNAF(); }
    required port NA_incNA{ void incNAF(); }
    required port NA_doubleNA{ void doubleNAF(); }
    required port UR_incUR{ void incURF(); }
    required port UR_doubleUR{ void doubleURF(); }
}

composite AlurPlant(){
    component P1 p1inst();
    component P2 p2inst();
    component NA nainst();
    component UR urinst();
    component controller controllerinst();

    connector centralised  centrins(
                                    p1inst{incUR,incNA},
                                    p2inst{doubleUR, doubleNA},
                                    urinst{incUR,   doubleUR},
                                    nainst{incNA,   doubleNA},
                                    controllerinst { P1_incUR   , P1_incNA
                                                   , P2_doubleUR, P2_doubleNA
                                                   , UR_incUR   , UR_doubleUR
                                                   , NA_incNA   , NA_doubleNA }
                                    );
}

component AlurPlant config();
