component client(byte numOfPorts){ 
	    
	byte data := 0;     
	byte numOfOpenedServers := 0;  
	   
     
	required port service[numOfPorts]{ 
		@interaction{ 
			waits: numOfOpenedServers < numOfPorts;   
		} 
		@functional{  
		  promises: \nothing;
		  requires:true;		 
		  ensures: numOfOpenedServers:=pre(numOfOpenedServers) +1;
		}
		void open();   
		 
		@interaction{ 
		  waits: numOfOpenedServers > 0; 
		} 
		@functional{     
		  promises: \nothing;  
		  requires:true;				  
		  ensures: numOfOpenedServers:=pre(numOfOpenedServers) - 1;
		}
		void close();
		
		@interaction{  
		  waits: numOfOpenedServers == numOfPorts;
		}
		@functional{
		  promises:\nothing;
		  requires:true;				
		  ensures: data:= \result;
		} 
		byte request();				
	}
	
}

component server(byte numOfPorts){
	byte data := 1;
	
	provided port service[numOfPorts] {

		void open();
		void close();
		
		@functional{
		  requires:true;				
		  ensures: \result := data  ; 
		}  
		byte request();			  	
	}	  
}                           
  
component mixedComponent(byte numOfClientPorts, byte numOfServerPorts){
	byte numOfOpenedServers := 0;
	byte data := 3;	    
 
//	[blocking]
	required port client[numOfClientPorts]{   
		@interaction{ 
			waits: numOfOpenedServers < numOfClientPorts;  
		}
		@functional{ 
		  promises: \nothing;
		  requires:true;				   
		  ensures: numOfOpenedServers:=numOfOpenedServers +1;
		}
		void open();   
		   
		@interaction{ 
		  waits: numOfOpenedServers > 0;      
		} 
		@functional{   
		  promises: \nothing;
		  requires:true;			 
		  ensures: numOfOpenedServers:=numOfOpenedServers - 1;
		}
		void close();  
		
		@interaction{ 
		  waits:numOfOpenedServers == numOfClientPorts;
		} 
		@functional{
		  promises: \nothing;
		  requires:true;				
		  ensures: data := \result;
		}  
		byte request();				
	}

	provided port server[numOfServerPorts]{ 
		  
		@interaction_req{
		 waits: numOfOpenedServers == numOfClientPorts;
		}	
		void open(); 
		 
		@interaction_req{
		  waits: numOfOpenedServers == numOfClientPorts;
		}		
		void close();   
   
		@interaction_req{
		  waits: numOfOpenedServers == numOfClientPorts;   
		}			  
		@functional_res{   
		  ensures: \result := data;
		}
		byte request();		
	}                                        	                           
}                                

connector client2server(client{service}, server{service}){   
	          
	role client{
		bool opened := false;     
		required port_variable service{    
			@interaction{
				waits: !opened; 
				ensures: opened := true; 
			} 
			void open(); 		 			     
			@interaction{
				waits: opened; 
				ensures: opened := false;
			}
			void close(); 	
			@interaction{
				waits: opened  ;  
				ensures: \nothing; 
			}			 
			byte request();   
		}        
	}              
	  
	role server{       
		bool opened:=false;  
		provided port_variable service{  
  
			@interaction{  
				waits: !opened;
				ensures: opened:=true;
			}		
			void open();
			@interaction{
				waits: opened;
				ensures: opened:= false;
			}						
			void close();
			@interaction{
				waits: opened; 
				ensures: \nothing;
			}			 	  
			byte request();			
		}
	}
	   
	connector proc link(client{service}, server{service}); 
}

component aegis(){
	
	component server experimentControl(3);
	component mixedComponent doctrineAuthoring(1,3);
	component client doctrineValidation(3);
	component mixedComponent trackServer(1,3);
	component mixedComponent geoServer(2,1);
	component client doctrineReasoning(3);
	
	connector client2server cs_1(doctrineAuthoring{client[0]}, experimentControl{service[0]});
	connector client2server cs_2(doctrineValidation{service[0]},experimentControl{service[1]});
        connector client2server cs_3(trackServer{client[0]},experimentControl{service[2]});
	connector client2server cs_4(doctrineValidation{service[1]},doctrineAuthoring{server[0]});
	connector client2server cs_5(doctrineValidation{service[2]},trackServer{server[0]});
	connector client2server cs_6(doctrineReasoning{service[0]},doctrineAuthoring{server[1]});
	connector client2server cs_7(geoServer{client[0]},doctrineAuthoring{server[2]});
	connector client2server cs_8(doctrineReasoning{service[1]},trackServer{server[1]}); 
	connector client2server cs_9(geoServer{client[1]},trackServer{server[2]});
	connector client2server cs_10(doctrineReasoning{service[2]}, geoServer{server[0]});	
}   
 
 component aegis configAegis();
